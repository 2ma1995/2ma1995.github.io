[
  
  {
    "title": "접근 제어자",
    "url": "/posts/java-access_modifier/",
    "categories": "Java, Study",
    "tags": "OOP, encapsulation, AccessModifier, java-basic",
    "date": "2025-09-03 20:32:00 +0900",
    "content": "✅ 접근 제어자 이해  접근제어자란? - 해당 클래스 외부에서 특정 필드나 메서드에 접근하는 것을 허용하거나 제한할수있는것.  에어컨 예제)    에어컨은 최고온도나 최저온도를 넘을수 없다.(넘어가면 에어컨이 고장난다.)   아래는 에어컨의 객체다.     package access;  public class AirConditioner {     int temperature;      // 생성자     public AirConditioner(int temperature) {         this.temperature = temperature;     }      // 온도 올리기     public void increaseTemp() {         if (temperature &gt;= 30) {             System.out.println(\"최고 온도입니다. 더 이상 온도를 올릴 수 없습니다.\");         } else {             temperature += 1;             System.out.println(\"온도를 1도 올립니다.\");         }     }      // 온도 내리기     public void decreaseTemp() {         if (temperature &lt;= 18) {             System.out.println(\"최저 온도입니다. 더 이상 온도를 내릴 수 없습니다.\");         } else {             temperature -= 1;             System.out.println(\"온도를 1도 내립니다.\");         }     }      // 현재 온도 확인     public void showTemperature() {         System.out.println(\"현재 설정 온도: \" + temperature + \"도\");     } }    AirConditionerMain  package access;  public class AirConditionerTest {     public static void main(String[] args) {         AirConditioner ac = new AirConditioner(22);          ac.showTemperature();         ac.increaseTemp();         ac.decreaseTemp();         ac.decreaseTemp();         ac.showTemperature();     } }    실행이 잘되는 코드이지만, 새로운 신입 개발자가 입사해,전후사정을 모르고 한계점을 넘게 설정을 했다고 가정하자.    package access;  public class AirConditionerTest {     public static void main(String[] args) {         AirConditioner ac = new AirConditioner(22);          ac.showTemperature();         ac.increaseTemp();         ac.decreaseTemp();         ac.decreaseTemp();         ac.showTemperature();                  //필드에 직점 접근       System.out.println(\"temperature필드에 직접 접근 수정\");       ac.temperature = 15;       ac.showTemperature();     } }  위의 코드가 실행이된다. 이렇게, AirConditioner객체를 사용하는 사용자는 AirConditioner의 temperature필드와 메서드에 모두 접근가능하다. 이런 상황에서 필드의 외부접근을 막을수 있는 방법이 필요하다.    해결방법    이 문제를 근본적으로 해결하는 방법은 temperature 필드를 AirConditioner 클래스 외부에서는 접근하지 못하게 막는 것!     package access;  public class AirConditioner {      private int temperature;   // ... }           private 접근 제어자는 모든 외부 호출을 막는다. 해당 클래스 내부에서만 호출 가능     🧱 접근 제어자 종류     자바는 총 4가지 졸유의 접근 제어자 제공      private: 모든 외부 호출 막음   default(package-private): 같은 패키지안에서 호출 허용   protected: 같은 패키지안에서만 호출 허용(패키지가 달라도 상속관계호출은 가능)   public: 모든 외부 호출 허용   순서대로 private가 차단이 높고, public은 차단이 없음 private -&gt; default -&gt; protected -&gt; public  package-private란? 접근제어자를 명시하지 않을때, 같은 패키지 안에서 호출을 허용하는 default접근 제어자가 적용, default 라는 용어는 해당 접근 제어자가 기본값으로 사용되기 때문에 붙여진 이름이지만,  실제로는 package-private 가 더 정확한 표현이다. 정리해서 해당 접근 제어자를 사용하는 멤버는 동일한 패키지 내의 다른 클래스에서만 접근이 가능하다.  접근 제어자 사용 위치 접근 제어자는 필드와 메서드, 생성자에 사용(클래스 레벨에도 일부 접근 제어자 사용가능)  접근 제어자의 핵심은 속성과 기능을 외부로부터 숨기는 것!    private는 사용중인 클래스 안으로 속성과 기능을 숨길 때, (외부클래스 제한)   default는 사용중인 패키지 안으로 속성과 기능을 숨길 때, (외부패키지 제한)   protected는 상속 관계로 속성과 기능을 숨길 때, (상속관계가 아니면 제한)   public은 기능을 숨기지 않음 (어디든 사용가능)   protected 예제  package access.parent;  public class Parent {     protected int value = 100; }    package access.child; import access.parent.Parent; public class Child extends Parent {     public void printValue() {         System.out.println(\"상속받은 value = \" + value);     } }    자바에서 클래스, 필드, 메서드, 생성자의 접근 가능 범위를 제어하는 키워드. 객체 지향의 중요한 개념인 캡슐화(Encapsulation)를 완성하는 핵심 장치.  필드와 메서드 레벨 접근 제어자  ✅ AirConditioner 예제  package access.a  public class AirConditioner { public int publicTemp = 24;     // 누구나 접근 가능 int defaultTemp = 22;           // 같은 패키지에서만 접근 가능 private int privateTemp = 20;   // 클래스 내부에서만 접근 가능      public void publicMethod() {         System.out.println(\"publicMethod 호출 \" + publicTemp);     }      void defaultMethod() {         System.out.println(\"defaultMethod 호출 \" + defaultTemp);     }      private void privateMethod() {         System.out.println(\"privateMethod 호출 \" + privateTemp);     }      // 내부에서만 private 멤버 접근 확인     public void innerAccess() {         System.out.println(\"내부 호출\");         publicTemp = 30;         defaultTemp = 28;         privateTemp = 26;          publicMethod();         defaultMethod();         privateMethod();     } }    같은 패키지에서 접근 —  package access.a;  public class AirConditionerInnerMain { public static void main(String[] args) { AirConditioner ac = new AirConditioner();          // public 접근 가능         ac.publicTemp = 25;         ac.publicMethod();          // default 접근 가능 (같은 패키지)         ac.defaultTemp = 23;         ac.defaultMethod();          // private 접근 불가         // ac.privateTemp = 21;         // ac.privateMethod();          ac.innerAccess(); // 내부에서 private도 접근 가능     } }   다른 패키지에서 접근 —  package access.b; import access.a.AirConditioner;  public class AirConditionerOuterMain { public static void main(String[] args) { AirConditioner ac = new AirConditioner();          // public 접근 가능         ac.publicTemp = 25;         ac.publicMethod();          // default 접근 불가 (다른 패키지)         // ac.defaultTemp = 23;         // ac.defaultMethod();          // private 접근 불가         // ac.privateTemp = 21;         // ac.privateMethod();          ac.innerAccess(); // public 메서드라 접근 가능     } }   3. 클래스 레벨 접근 제어자     클래스에는 public, default만 사용 가능   public 클래스는 파일명과 동일해야 함   하나의 자바 파일에 public 클래스는 1개만 가능, default 클래스는 여러 개 가능 ```java package access.a;   public class PublicClass { public static void main(String[] args) { PublicClass pub = new PublicClass(); DefaultClass1 d1 = new DefaultClass1(); DefaultClass2 d2 = new DefaultClass2(); } }  class DefaultClass1 {} class DefaultClass2 {} --- ## 4. 캡슐화(Encapsulation) 개념 - 데이터(필드)와 기능(메서드)을 하나로 묶고, 불필요한 것은 숨기고 필요한 것만 노출하는 것 - 데이터는 반드시 숨기고(private), 외부에서는 제공된 메서드를 통해서만 접근해야 함  ### ✅ BankAccount 예제 (캡슐화 적용) ```java package access;  public class BankAccount { private int balance; // 데이터를 직접 접근 못 하게 보호      public BankAccount() {         balance = 0;     }      // 입금 (public)     public void deposit(int amount) {         if (isAmountValid(amount)) {             balance += amount;             System.out.println(amount + \"원 입금 완료\");         } else {             System.out.println(\"유효하지 않은 금액입니다.\");         }     }      // 출금 (public)     public void withdraw(int amount) {         if (isAmountValid(amount) &amp;&amp; balance - amount &gt;= 0) {             balance -= amount;             System.out.println(amount + \"원 출금 완료\");         } else {             System.out.println(\"유효하지 않은 금액이거나 잔액 부족\");         }     }      // 잔고 조회 (public)     public int getBalance() {         return balance;     }      // 금액 검증 (private → 내부에서만 사용)     private boolean isAmountValid(int amount) {         return amount &gt; 0;     } }  BankAccountMain package access;  public class BankAccountMain { public static void main(String[] args) { BankAccount account = new BankAccount();          account.deposit(10000);         account.withdraw(3000);         account.withdraw(8000);          System.out.println(\"최종 잔액 = \" + account.getBalance());     } }  📌 정리  접근 제어자    public: 모든 곳 접근 가능   default: 같은 패키지에서만   private: 클래스 내부에서만   protected: (지금 예제엔 없지만) 같은 패키지 + 상속 관계 접근 가능   클래스 레벨    public, default만 가능   public은 파일명과 같아야 함   캡슐화    데이터(필드)는 반드시 private   외부에는 꼭 필요한 public 메서드만 제공   내부 동작 검증용 메서드는 private으로 숨김  "
  },
  
  {
    "title": "생성자(Constructor)",
    "url": "/posts/java-Construct/",
    "categories": "Java, Study",
    "tags": "constructor, class, object, init",
    "date": "2025-08-28 18:30:00 +0900",
    "content": "✅ 생성자  객체를 생성하는 시점에 어떠한 작업을 하려면 생성자(Constructor)를 이용 해야 된다.  1. 필드만 있는 클래스 (CarInit) package construct;  public class CarInit {     String model;     String color;     int maxSpeed; }  2. 값을 일일이 직접 넣는 방식(CarInitMain1) package construct;  public class CarInitMain1 {     public static void main(String[] args) {         CarInit car1 = new CarInit();         car1.model = \"Avante\";         car1.color = \"White\";         car1.maxSpeed = 180;          CarInit car2 = new CarInit();         car2.model = \"Sonata\";         car2.color = \"Black\";         car2.maxSpeed = 200;          CarInit[] cars = {car1, car2};         for (CarInit car : cars) {             System.out.println(\"모델:\" + car.model + \", 색상:\" + car.color + \", 최고속도:\" + car.maxSpeed + \"km/h\");         }     } }  문제점    model, color, maxSpeed 값을 매번 수동으로 넣어야 함        같은 코드 반복 작성     3. 초기화 메서드를 사용한 개선 (CarInitMain2)     ```java package construct;      public class CarInitMain2 {   public static void main(String[] args) {     CarInit car1 = new CarInit();     initCar(car1, “Avante”, “White”, 180);  CarInit car2 = new CarInit(); initCar(car2, \"Sonata\", \"Black\", 200);  CarInit[] cars = {car1, car2}; for (CarInit car : cars) {   System.out.println(\"모델:\" + car.model + \", 색상:\" + car.color + \", 최고속도:\" + car.maxSpeed + \"km/h\"); }   }   static void initCar(CarInit car, String model, String color, int maxSpeed) {     car.model = model;     car.color = color;     car.maxSpeed = maxSpeed;   } } --- ### ✅ 개선점 - 중복 제거 - 코드 가독성 증가 ### ❌ 여전히 문제점 - 여전히 CarInit의 데이터는 외부에서 초기화 - 속성과 초기화 로직이 분리되어 있음 → 객체지향적으로 적절하지 않음 ### 4. 생성자 도입 (Car) ```java package construct;  public class Car {   String model;   String color;   int maxSpeed;    // 생성자   public Car(String model, String color, int maxSpeed) {     this.model = model;     this.color = color;     this.maxSpeed = maxSpeed;   } }  5. 생성자 사용 (CarMain) package construct;  public class CarMain {     public static void main(String[] args) {         Car car1 = new Car(\"Avante\", \"White\", 180);         Car car2 = new Car(\"Sonata\", \"Black\", 200);          Car[] cars = {car1, car2};         for (Car car : cars) {             System.out.println(\"모델:\" + car.model + \", 색상:\" + car.color + \", 최고속도:\" + car.maxSpeed + \"km/h\");         }     } }  장점    객체 생성과 동시에 초기화 → 실수로 초기화 안 하는 경우 방지        코드가 간결해짐     6. 기본생성자     ```java package construct;      public class CarDefault {   String model;   String color;   int maxSpeed;  // 기본 생성자 (매개변수 없음)   public CarDefault() {     System.out.println(“기본 생성자 호출”);   } } ### 사용코드(CarMain) ```java package construct;  public class CarMain {     public static void main(String[] args) {         Car car1 = new Car(\"Avante\", \"White\", 180);         Car car2 = new Car(\"Sonata\", \"Black\", 200);          Car[] cars = {car1, car2};         for (Car car : cars) {             System.out.println(\"모델:\" + car.model + \", 색상:\" + car.color + \", 최고속도:\" + car.maxSpeed + \"km/h\");         }     } }   클래스에 생성자를 하나도 정의하지 않으면 자바가 자동으로 기본 생성자를 만들어준다. 하지만 생성자를 직접 정의하면 기본 생성자는 자동으로 만들어지지 않는다. — 7. 생성자 오버로딩 package construct;  public class CarOverload {   String model;   String color;   int maxSpeed;    // 생성자1   public CarOverload(String model, String color) {     this(model, color, 150); // this()로 다른 생성자 호출   }    // 생성자2   public CarOverload(String model, String color, int maxSpeed) {     this.model = model;     this.color = color;     this.maxSpeed = maxSpeed;   } }  사용예시 package construct;  public class CarOverloadMain {   public static void main(String[] args) {     CarOverload car1 = new CarOverload(\"Avante\", \"White\", 180);     CarOverload car2 = new CarOverload(\"Sonata\", \"Black\"); // maxSpeed 기본값 150      System.out.println(car1.model + \" / \" + car1.color + \" / \" + car1.maxSpeed);     System.out.println(car2.model + \" / \" + car2.color + \" / \" + car2.maxSpeed);   } }    🔑 정리    생성자는 객체 생성 직후 반드시 호출된다.   생성자를 사용하면 필수 데이터 입력을 강제할 수 있다.   기본 생성자는 직접 생성자를 정의하지 않을 때만 자동 추가된다.        생성자 오버로딩과 this()를 활용하면 중복 제거 및 유연한 객체 생성이 가능하다.     "
  },
  
  {
    "title": "객체 지향 프로그래밍",
    "url": "/posts/java-Object-Oriented-Programming/",
    "categories": "Java, Study",
    "tags": "OOP, encapsulation, class, java-basic",
    "date": "2025-08-28 17:44:00 +0900",
    "content": "✅ 절차 지향 프로그래밍 vs 객체지향 프로그래밍     절차 지향 프로그래밍            절차 지향 프로그래밍은 이름 그대로 절차를 지향, 실행순서를 중요하게 생각하는 방식       절차 지향 프로그래밍은 프로그램의 흐름을 순차적으로 따르며 처리, “어떻게”를 중심으로 프로그래밍 한다.           객체 지향 프로그래밍            객체 지향 프로그래밍은 이름 그대로 객체를 지향, 객체를 중요하게 생각하는 방식       객체 지향 프로그래밍은 실제 세계의 사물이나 사건을 객체로 보고, 객체들간의 상호작용을 중심으로 프로그래밍 하는 방식. “무엇을” 중심으로 프로그래밍           둘의 중요한차이            절차지향은 데이터와 해당 데이터에 대한 ㅊ리 방식이 분리 되어 있음       객체지향은 데이터와 그 데이터에 대한 행동(메서드)이 하나의 ‘객체’안에 함께 포함 되어있다.             🧱 절차 지향 -&gt; 객체 지향 에어컨 제어 시스템  요구사항:    에어컨을 켜고 끌 수 있어야 한다.   에어컨의 온도를 증가, 감소할 수 있어야한다.   에어컨의 상태(on/off,현재 온도)를 확인 할 수 있어야 한다.   🔹 절차지향 1 - 변수로만 구현 package oop1;  public class AirConditionerMain1 {   public static void main(String[] args) {     int temperature = 24;     boolean isOn = false;      // 에어컨 켜기     isOn = true;     System.out.println(\"에어컨을 시작합니다\");      // 온도 증가     temperature++;     System.out.println(\"에어컨 온도: \" + temperature);      // 온도 감소     temperature--;     System.out.println(\"에어컨 온도: \" + temperature);      // 상태 확인     System.out.println(\"에어컨 상태 확인\");     if (isOn) {       System.out.println(\"에어컨 ON, 온도: \" + temperature);     } else {       System.out.println(\"에어컨 OFF\");     }      // 에어컨 끄기     isOn = false;     System.out.println(\"에어컨을 종료합니다\");   } }          순서대로 프로그램이 작동하도록 단순 작성     🔹 절차지향 2 - 데이터 묶음     클래스를 도입하고, AirConditionerData라는 클래스를 만들고, 에어컨에 사용되는 데이터들을 묶어서 멤버 변수로 사용      package oop1;  public class AirConditionerData {   int temperature = 24;   boolean isOn = false; }  에어컨에 사용되는 temperature, isOn 속성을 AirConditionerData의 멤버 변수에 포함  package oop1;  public class AirConditionerMain2 {   public static void main(String[] args) {     AirConditionerData ac = new AirConditionerData();      // 에어컨 켜기     ac.isOn = true;     System.out.println(\"에어컨을 시작합니다\");      // 온도 증가     ac.temperature++;     System.out.println(\"에어컨 온도: \" + ac.temperature);      // 온도 감소     ac.temperature--;     System.out.println(\"에어컨 온도: \" + ac.temperature);      // 상태 확인     System.out.println(\"에어컨 상태 확인\");     if (ac.isOn) {       System.out.println(\"에어컨 ON, 온도: \" + ac.temperature);     } else {       System.out.println(\"에어컨 OFF\");     }      // 에어컨 끄기     ac.isOn = false;     System.out.println(\"에어컨을 종료합니다\");   } }  에어컨과 관련된 변수들은 AirConditionerData ac 객체에 속해있으므로 쉽게 구분할 수 있다. — 🔹 절차지향 3 - 메서드 추출 중복되는 부분 : 온도 증가, 온도 감소 각 기능들의 재사용 가능성 : 에어컨 켜기/끄기 , 에어컨 상태확인 메서드를 사용 해 각 기능을 구분하여 실행 package oop1;  public class AirConditionerMain3 {   public static void main(String[] args) {     AirConditionerData ac = new AirConditionerData();      turnOn(ac);     increaseTemperature(ac);     decreaseTemperature(ac);     showStatus(ac);     turnOff(ac);   }    static void turnOn(AirConditionerData ac) {     ac.isOn = true;     System.out.println(\"에어컨을 시작합니다\");   }    static void turnOff(AirConditionerData ac) {     ac.isOn = false;     System.out.println(\"에어컨을 종료합니다\");   }    static void increaseTemperature(AirConditionerData ac) {     ac.temperature++;     System.out.println(\"에어컨 온도: \" + ac.temperature);   }    static void decreaseTemperature(AirConditionerData ac) {     ac.temperature--;     System.out.println(\"에어컨 온도: \" + ac.temperature);   }    static void showStatus(AirConditionerData ac) {     System.out.println(\"에어컨 상태 확인\");     if (ac.isOn) {       System.out.println(\"에어컨 ON, 온도: \" + ac.temperature);     } else {       System.out.println(\"에어컨 OFF\");     }   } }  각각의 기능을 메서드로 만들어 기능이 모듈화 되었고, 장점이 생김.    중복 제거: 로직 중복이 제거. 같은 로직이 필요하면 해당 메서드를 여러번 호출하면 된다.   변경 영향 범위: 기능을 수정할 때 해당 메서드 내부만 변경하면 된다.        메서드 이름 추가: 메서드 이름을 통해 코드를 더 쉽게 이해할 수 있다.     절차지향 프로그래밍의 한계      AirConditionerData는 단지 값만 가지고 있고,   AirConditionerMain3은 기능만 가지고 있음 → 데이터와 기능이 분리됨 ➡️ 유지보수할 때 양쪽 다 수정해야 함. ➡️ 객체 하나를 표현하는 데 관련된 코드가 여러 클래스에 흩어짐. —   🔗 객체 지향 프로그래밍 데이터와 기능을 하나로 묶어서 에어컨을 하나의 클래스로 만들고, 속성(데이터)을 가지고 기능(메서드)을 제공하는지에 초점 에어컨    속성: temperature, isOn   기능: turnOn, turnOff, increaseTemperature, decreaseTemperature, showStatus   package oop2;  public class AirConditioner {   private int temperature = 24;   private boolean isOn = false;    public void turnOn() {     isOn = true;     System.out.println(\"에어컨을 시작합니다\");   }    public void turnOff() {     isOn = false;     System.out.println(\"에어컨을 종료합니다\");   }    public void increaseTemperature() {     temperature++;     System.out.println(\"에어컨 온도: \" + temperature);   }    public void decreaseTemperature() {     temperature--;     System.out.println(\"에어컨 온도: \" + temperature);   }    public void showStatus() {     System.out.println(\"에어컨 상태 확인\");     if (isOn) {       System.out.println(\"에어컨 ON, 온도: \" + temperature);     } else {       System.out.println(\"에어컨 OFF\");     }   } }  package oop2;  public class AirConditionerMain {     public static void main(String[] args) {         AirConditioner ac = new AirConditioner();          ac.turnOn();         ac.increaseTemperature();         ac.decreaseTemperature();         ac.showStatus();         ac.turnOff();     } }     ➡️ 데이터와 기능을 하나로 묶는 것(캡슐화)은 객체지향의 핵심 원칙 중 하나이며, 현실 세계의 객체처럼 소프트웨어에서도 자연스럽게 객체를 표현할 수 있게 해준다. —  "
  },
  
  {
    "title": "Java 기본형 vs 참조형 요약",
    "url": "/posts/java-primitiveType_referenceType/",
    "categories": "Java, Study",
    "tags": "primitive, reference, datatype, java-basic",
    "date": "2025-08-20 15:30:00 +0900",
    "content": "✅ Java 데이터 타입 분류  자바의 데이터 타입은 크게 두 가지로 나뉜다:     기본형 (Primitive Type)   참조형 (Reference Type)     🧱 기본형 (Primitive Type)     데이터를 직접 값으로 저장한다.   총 8가지 타입이 존재한다.   메모리(stack)에 실제 값을 저장함.                  타입       크기       예시 값                       byte       1B       100                 short       2B       32000                 int       4B       123                 long       8B       123456789L                 float       4B       3.14f                 double       8B       3.14159                 char       2B       ‘A’                 boolean       1B       true / false           int a = 10; char ch = 'A'; boolean isAdult = true;          위처럼 변수에 사용할 값을 직접 넣을 수 있는 데이터 타입을 기본형이라 한다.      🔗 참조형 (Reference Type)     객체(Object)의 주소값을 저장한다.   클래스, 배열, 인터페이스 등 대부분의 사용자 정의 데이터.   heap에 객체 데이터를 만들고, 그 주소를 stack에 저장.   String name = \"Alice\";           // String 객체의 주소 저장 int[] scores = {90, 80, 100};    // 배열도 참조형 Student student = new Student(); // 클래스도 참조형          위처럼 데이터에 접근하기 위한 참조(주소)를 저장하는 데이터 타입을 참조형이라고 한다. 참조형은 객체 또는 배열에 사용한다.      🧠 주요 차이                 비교 항목       기본형 (Primitive)       참조형 (Reference)                       저장 내용       실제 값 (value)       객체 주소 (reference)                 메모리 위치       Stack       객체는 Heap, 참조는 Stack                 null 저장       ❌ 불가능       ✅ 가능 (null로 초기화 가능)                 예시       int, double, boolean       String, 배열, 사용자 클래스             기본형 vs 참조형 - 기본    기본형은 숫자 10, 20과 같이 실제 사용하는 값을 변수에 담을 수 있다.(해당값 바로 사용할수 있음)   참조형은 실제 사용하는 값을 변수에 담는 것이 아님, 이름 그대로 실제 객체의 위치(참조,주소)를 저장한다. 참조형에는 객체와 배열이 있음            객체는 .(dot)을 통해서 메모리 상에 생성된 객체를 찾아가 사용       배열은 []를 통해서 메모리 상에 생성된 객체를 찾아가 사용           기본형 vs 참조형 - 계산    기본형은 들어있는 값을 그대로 계산에 사용            ex) 더하고 빼고, 사용하고 등(숫자 같은 것들은 바로 계산)           참조형은 들어있는 참조값을 그대로 사용할 수 없다. 주소지만 가지고 할 수 있는게 없음, 주소지에 가야 사용가능            ex) 더하고 빼고 사용하고 못함, 참조값만 가지고는 계산불가.            📌 예제 비교  int x = 10; int y = x;       // 값 복사  x = 20; System.out.println(y);  // 10 (영향 X)   int[] arr1 = {1, 2, 3}; int[] arr2 = arr1;   // 주소 복사  arr1[0] = 99; System.out.println(arr2[0]); // 99 (같은 객체를 가리킴)      👉 기본형은 값을 복사, 참조형은 주소를 공유한다는 점이 핵심!     🧠 기본형 vs 참조형: 메서드 호출  자바는 항상 변수의 값을 복사해서 대입한다. 이 원칙은 메서드 호출 시에도 동일하게 적용된다.    ✅ 기본형: 값만 복사  public class MethodChange1 {   public static void main(String[] args) {     int a = 10;     System.out.println(\"메서드 호출 전: a = \" + a);     changePrimitive(a);     System.out.println(\"메서드 호출 후: a = \" + a);   }    static void changePrimitive(int x) {     x = 20;   } }   실행 결과:  메서드 호출 전: a = 10 메서드 호출 후: a = 10   설명    a의 값이 x에 복사됨 → 두 변수는 별개   x = 20은 a에 영향을 주지 않음     ✅ 참조형: 참조값이 복사됨  public class MethodChange2 {   public static void main(String[] args) {     Data dataA = new Data();     dataA.value = 10;     System.out.println(\"메서드 호출 전: dataA.value = \" + dataA.value);     changeReference(dataA);     System.out.println(\"메서드 호출 후: dataA.value = \" + dataA.value);   }    static void changeReference(Data dataX) {     dataX.value = 20;   } }   실행 결과:  메서드 호출 전: dataA.value = 10 메서드 호출 후: dataA.value = 20   설명    dataA의 참조값이 dataX에 복사됨 → 두 변수는 같은 객체를 가리킴   dataX.value = 20은 dataA.value에도 영향     ✅ 정리                 구분       전달 방식       메서드 내부 변경 시 호출자에 영향                       기본형       값 복사       ❌ 없음                 참조형       참조값 복사       ✅ 있음              자바의 매개변수 전달은 항상 값에 의한 전달(Call by Value).   기본형은 실제 값을, 참조형은 주소(참조값)를 복사.     ✅ 핵심 요약     변수에 대입 = 값 복사   메서드 호출 = 매개변수도 값 복사   참조형의 경우 복사된 값이 참조값이라 객체 내용은 변경 가능     🧪 null 주의  Student s = null; System.out.println(s.name); // ❌ NullPointerException     ✅ 요약     기본형: 숫자, 문자, 논리 등 값 자체를 다룸   참조형: 객체나 배열 등 실제 데이터 위치를 가리킴   참조형은 null, 공유, heap 등을 항상 염두에 둘 것    "
  },
  
  {
    "title": "Java 클래스 요약",
    "url": "/posts/java-class-summary/",
    "categories": "Java, Study",
    "tags": "class, OOP, java-basic",
    "date": "2025-08-12 15:00:00 +0900",
    "content": "📌 클래스와 데이터 문제상황    학생 정보를 다룰 때 이름, 나이, 성적 등 여러 데이터를 저장해야 함   변수로 처리하면: 학생 1명당 3개의 변수 필요 → 학생 늘어나면 코드 폭발   배열로 처리하면: 데이터가 나뉘어 저장됨 → 인덱스 관리 어려움, 실수 위험      💡 클래스를 사용하면 관련 데이터를 묶어서 구조화할 수 있어 유지보수에 유리합니다.   해결책: 클래스  public class Student {   String name;   int age;   int grade; }  하나의 객체에 관련 데이터를 묶어서 표현 Student student1 = new Student(); // Student 클래스 기반 객체 생성 student1.name = \"학생\";            // 객체의 필드에 값 할당 student1.age = 15; student1.grade = 90;     객체 생성: new 클래스명()   객체 참조: 객체변수.멤버변수   ✅ 자바 클래스 핵심 요약    ✅ 클래스 = 사용자 정의 타입     int, String처럼 직접 만든 데이터 타입이 될 수 있음   클래스를 사용하면 현실 세계의 개념(학생, 자동차 등)을 프로그래밍 세계에 맞게 표현할 수 있음   클래스는 설계도, 객체는 그 설계도로 만들어진 실제 실체 (= 인스턴스)     ✅ 클래스 도입 효과                 방법       단점 또는 문제점                       변수       학생 늘어나면 변수 폭발                 배열       관련 데이터가 배열로 나뉘어 관리 어려움                 클래스       ✅ 관련 데이터를 묶어 구조화, 유지보수 용이             ✅ 용어 정리                 클래스(Class)       객체를 만들기 위한 설계도, 사용자 정의 데이터 타입                       객체(Object) / 인스턴스(Instance)       클래스를 바탕으로 만들어진 메모리 상의 실제 실체 (동일한 의미로 사용됨)                       필드(Field)       클래스 내부에 선언된 변수 (= 멤버 변수). 객체의 상태(데이터)를 저장함           배열과 클래스    Student[] students = new Student[2]; 형태로 배열 선언   객체 배열을 통해 여러 학생 정보를 관리할 수 있음   Student[] students = {student1, student2}; for (Student s : students) {     System.out.println(\"이름:\" + s.name + \" 나이:\" + s.age + \" 성적:\" + s.grade); }  "
  }
  
]

