[
  
  {
    "title": "Spring 3대 요소",
    "url": "/posts/spring-3%EB%8C%80_%EC%9A%94%EC%86%8C/",
    "categories": "Spring, Study",
    "tags": "Spring, Spring-Container, IoC, AOP, PSA, 의존성주입",
    "date": "2025-09-12 15:51:00 +0900",
    "content": "✅ spring 3대 요소    spring 3대 요소 - 스프링은 3 개의 요소가 있다. IoC/DI, PSA, AOP  제어의 역전 (Inversion of Control)  개념    객체 생성 및 의존 관계 관리를 개발자가 아닌 Spring컨테이너에 위임하는 소프트웨어 디자인 원칙   원칙    컴포넌트 의존관계 설정, 설정, 생명주기 를 해결하기 위한 디자인 패턴   장점    낮은 결합도 : 객체간의 의존성을 낮춰 코드의 유연성, 재사용성 증가   높은 응집도 : 객체는 자신의 핵심 기능만 집중하고, 의존성 관리는 컨테이너에 위임하여 코드의 가독성과 유지 보수성이 향상   테스트 용이성 : 컨테이너를 통해 의존성을 쉽게 교체하거나 목 객체(Mock Object)를 주입하여, 단위 테스트를 효과적으로 수행   스프링에서의 활용    XML / Annotation기반 설정 : 개발자는 XML설정파일 이나, 어노테이션(@)을 통해 객체의 의존 관계를 설정   IoC 컨테이너 : 스프링 컨테이너는 설정 정보를 기반으로 객체를 생성, 의존성을 자동으로 주입   런타임 의존성 주입 : 애플리케이션 실행 시점에 컨테이너가 동적으로 의존성을 주입, 코드 변경 없이 객체 간의 관계를 변경 가능     IoC컨테이너 란?    객체를 생성하고 의존성을 관리하고 책임지는 컨테이너   인스턴스 생성부터 소멸까지 인스턴스의 생명주기를 개발자가 아닌 IoC컨테이너가 대신 해준다.   객체 관리 주체가 개발자가 아닌 스프링 프레임워크(제어의 반전) 가 되기 때문에, 개발자는 로직에 더 집중 할수 있게 된다.   IoC와 싱글톤(Singleton)패턴  싱글톤 패턴    개념 : 애플리케이션 전체에서 특정 클래스의 인스턴스가 단 하나만 생성되도록 보장하는 디자인 패턴   목적 : 메모리 사용량을 줄이고, 객체 생성 비율을 절감하며, 전역적인 접근을 가능하게 한다.   싱글톤의 핵심 구성요소    private 생성자 : 외부에서 객체를 직접 생성하지 못하도록 제한   정적 인스턴스 변수 : 클래스 내부에 유일한 인스턴스 저장   정적 메서드 : 외부에서 유일한 인스턴스를 얻을 수 있도록 제공   IoC와 싱글톤 패턴의 관계 Spring Framework는 IoC 컨테이너를 통해 싱글톤 패턴을 효과적으로 지원하며, 개발자가 더욱 효율적이고 유지 보수하기 쉬운 애플리케이션을 개발할 수 있도록 돕는다.   IoC의 분류 : 의존성 조회(Dependency LookUp = DL) &amp; 의존성 주입(Dependency Injection)    DL(Dependency LookUp)과 DI(Dependency Injection)이 있지만 DL은 컨테이너의 종속성이 증가하기 때문에 잘 쓰이지 않는다.   DL이란?    필요할 때 객체가 직접 컨테이너에서 의존 객체를 요청해서 조회하는 방식   DI 란?    객체를 직접 생성하는게 아닌 외부(IoC컨테이너)에서 생성한 후 주입 시켜주는 방식   의존성 주입 방법 : IoC컨테이너는 스프링 컨테이너에 객체들을 Bean으로 등록하여 관리 - 클래스 선언부에 @Component 사용   @Component @Controller, @Service, @Repository는 모두 @Component를 포함하고 있다.    의존성 주입 방법 3가지    생성자 주입   수정자 주입   필드 주입   생성자 주입    생성자를 통해 의존관계를 주입하는 방식   객체 생성 시 딱 한 번 호출되며, 필수 의존성을 강제할 수 있음   Spring에서 가장 권장하는 방법   Spring 4.3 이후부터는 @Autowired 생략 가능   final 키워드를 활용해 불변성 보장 가능     @Controller public class TestController {   private final TestService testService;   public TestController(TestService testService){   \tthis.testService = testService;   } }           수정자 주입    Setter 메서드를 통해 의존성 주입   final 사용 불가 (불변성 보장 어려움)   선택적 의존성 주입에 사용됨     @Controller public class TestController {   private TestService testService;   @Autowired   public void setTestService(TestService testService){   \tthis.testService = testService;   } }           필드 주입    필드에 직접 의존관계를 주입하는 방법(@Autowired)   코드가 짧아지는 장점이 있다, 하지만 외부에서 변경이 불가능하고 테스트 코드를 작성하기 힘들다.   편리하지만 SOLID중 SRP위반, 테스트가 불편,final선언 불가로 인한 불변성 보장이 되지 않는다, 순환 의존성 등의 문제로 인해 권장되지 않는 방법     @Controller public class TestController {   @Autowired   private TestService testService; }                IoC컨테이너 분류  BeanFactory    Bean 등록, 생성, 조회, 반환에 대한 관리   팩토리 디자인 패턴을 구현한 것으로 BeanFactory는 빈을 생성하고 분배하는 책임을 가진다. cf ) 팩토리 패턴 : 객체 생성을 캡슐화하여 객체 생성 과정을 유연하게 관리하고, 클라이언트 코드와 구체적인 객체 생성 로직을 분리하는 디자인 패턴   Application Context    BeanFactory의 모든 기능을 포함하며, 추가적으로 위에서 설명한 다양한 기능들을 제공   일반적으로 Spring 기반 애플리케이션 개발에서는 Application Context를 사용      빈(Bean) 관리 :  @Component, @Service, @Repository, @Controller 등의 어노테이션이 붙은 클래스들을 빈으로 등록하고 관리   메세지 국제화 : 애플리케이션에서 사용되는 메시지를 다국어로 지원할 수 있도록 도와줌   이벤트 처리 : 애플리케이션 내에서 발생하는 이벤트를 처리하고 관리할 수 있는 기능을 제공   리소스 관리 : 파일, 이미지, 설정 파일 등 애플리케이션에서 사용되는 다양한 리소스를 로드하고 관리   환경 추상화 : 애플리케이션이 실행되는 환경(개발, 테스트, 운영 등)에 따라 다른 설정을 적용할 수 있도록 지원     서비스 추상화 (Portable Service Abstraction : PSA) 환경의 변화와 관계없이 일관된 방식의 기술로의 접근 환경을 제공하는 추상화 구조     다양한 환경에서도 동일한 방식으로 사용 가능 : PSA를 통해 개발자는 특정 기술의 세부적인 구현 방식에 대해 깊이 알 필요 없이, 일관된 API나 인터페이스를 통해 기능을 활용   기술 변경에 대한 영향 최소화 : 시스템 내부에서 사용되는 기술이 변경되더라도, PSA 덕분에 상위 계층의 코드는 변경할 필요가 거의 없어 유지보수가 용이   개발 생산성 향상 : PSA는 개발자에게 익숙한 추상화 계층을 제공하여, 새로운 기술을 학습하는 데 드는 시간을 줄이고 개발 생산성을 높임   in Spring Web MVC    Spring Web MVC는 Spring 프레임워크에서 제공하는 웹 애플리케이션 개발을 위한 모듈   기존 Servlet 방식의 복잡성을 해소하고, 잘 만들어진 인터페이스들, 의존성같은 기술들을 기반으로 하여 Spring은 개발자에게 편리한 환경을 제공한다.   in Spring Transaction    JDBC는 DB에 접근하고 작업, 트랜잭션을 구현할 때는 연결, 작업할 쿼리문, commit, rollback하는 코드를 전부 작성해야 했다.   Spring에선 메소드에 @Transactional을 통해 트랜잭션 처리를 간단하게 할 수 있다.     관점 지향 프로그래밍 (Aspect Oriented Programming : AOP) AOP는 횡단 관심사를 효과적으로 관리하여 OOP의 한계를 극복하고, 더욱 객체 지향적인 개발을 가능하게 하는 강력한 도구  문제    OOP의 한계 : OOP는 코드 재사용성과 유지 보수성을 높이는 데 효과적이지만, 트랜잭션 처리, 보안 등 여러 모듈에 걸쳐 반복적으로 나타나는 공통 기능(횡단 관심사, Cross-Cutting Concern) 을 효과적으로 관리하기 어렵다. 이러한 공통 기능은 각 모듈에 직접 구현하면 코드 중복, 복잡성 증가, 핵심 로직과의 혼재 등의 문제가 발생   해결    AOP의 해결 : AOP는 이러한 문제를 해결하기 위해 등장. AOP는 부가 기능을 Aspect(관점)로 정의하여, 핵심 기능에서 부가 기능을 분리함으로써 핵심 기능을 설계하고 구현할 때 객체지향적인 가치를 지킬 수 있게 도와주는 개념   AOP는 기능을 핵심 관심 사항(Core Concern)과 공통 관심 사항(흩어져 있는 관심사,Cross Cutting Concern)으로 분리시키고 각각을 모듈화 하는 것을 의미     Core Concern   핵심 관심사, 비즈니스 로직과 같이 애플리케이션의 핵심 기능을 담당하는 부분   Cross-Cutting Concern   Core Concern을 실행하기 위한 DB연결, 로깅, 파일 입출력 등   Target   부가 기능을 부여할 대상(핵심 기능을 담고 있는 모듈)   Aspect (관점)   횡단 관심사를 모듈화한 단위   Advice와 PointCut을 함께 가지고 있다.     1) Advice(공통 기능 코드)   2) JointPoint   Advice가 적용될 수 있는 위치    3) Pointcut   Advice를 적용할 JoinPoint를 선별하는 기능을 정의한 모듈    4) Proxy   Target을 감싸서 Target에 대한 요청을 대신 받아주는 Wrapping Object    클라이언트에서 Target을 호출하면 실제 타켓이 아닌 Wrapper Object(=Proxy)가 호출되어 타겟 메소드 실행 전에 선처리, 후처리 실행    5) Weaving   핵심 기능 코드에 Aspect를 삽입하는 과정. 컴파일 시점, 클래스 로딩 시점, 런타임 시점에 Weaving이 가능   AOP와 프록시(Proxy) 패턴의 관계 프록시 패턴이란?    개념 : 다른 객체에 대한 접근을 제어하는 Wrapper객체를 만드는데 사용되는 디자인 패턴   목적 : 어플리케이션 코드에서 Cross Cutting Concern을 분리할 수 있어 모듈화 및 유지보수가 보다 용이, 접근 제어 및 부가기능을 추가하기 위함     특징            Spring은 타겟 객체에 대한 프록시를 만들어 제공       Target의 Wrapper 프록시는 RunTime에 생성된다.       프록시는 Advice를 Target 객체에 적용하면서 생성되는 객체           호출 전 : 프록시는 호출을 Intercept 한다 프록시는 Target 객체에 대한 호출을 가로챈 다음 Advice의 부가 기능 로직을 수행하고 난 후에 Target의 핵심 기능 로직을 호출 호출 후 : 메소드는 JoinPoint만 지원한다. Target(핵심 기능)의 메소드가 호출되는 런타임 시점에만 Advice(부가 기능)을 적용할 수 있다.  🔗 참고 자료 (출처) 자세한 내용은 yuri.log  참고하세요. "
  },
  
  {
    "title": "Spring 웹 계층 구조",
    "url": "/posts/spring-web%EA%B3%84%EC%B8%B5/",
    "categories": "Spring, Study",
    "tags": "Spring, 웹계층, 계층구조, MVC패턴, Controller, Service, Repository, Bean, 의존성주입",
    "date": "2025-09-10 16:36:00 +0900",
    "content": "✅ web 3-Tier Architecture    spring 웹 계층이란? - 스프링의 웹 계층은 크게 3 개로 나눌수 있다. Presentation Layer, Business Layer, Data Access Layer    프레젠테이션 계층 (Controller)    브라우저상의 웹 클라이언트의 요청 및 응답 처리   서비스 계층, 데이터 엑세스 계층에서 발생하는 Exception(예외)을 처리   @Controller 어노테이션 사용으로 작성된 Controller클래스가 이 계층에 속한다.   서비스 계층 (Service)    애플리케이션 비즈니스 로직 처리와 비즈니스와 관련된 도메인 모델의 적합성 검증   트랜잭션 관리   프레젠테이션 계층과 데이터 엑세스 계층 사이를 연결하는 역할, 두 계층이 직접적으로 통신하지 않게함.   Service인터페이스와 @Service 어노테이션을 사용하여 작성된 Service구현 클래스가 이 계층에 속한다.   데이터 액세스 계층 (Repository)    ORM(Mybatis, Hibernate)를 주로 사용하는 계층   DAO(Data Access Object) 인터페이스와 @Repository 어노테이션을 사용하여 작성된 DAO 구현 클래스가 이 계층에 속함   Database에 data를 CRUD 하는 계층   도메인 모델 계층    DB의 테이블과 매칭되는 클래스   Entity클래스 라고도 불림.   비즈니스 로직을 처리함.     Dtos    Dto(Data Transfer Object)는 계층 간에 데이터 교환을 위한 객체를 이야기하며, Dtos는 DTO객체들이 모여있는 영역을 의미.   뷰 템플릿 엔진에서 사용될 객체나 Repository 계층에서 결과로 넘겨준 객체등이 Dto이다.    DAO(Data Access Object) 란?     DB에 접근하는 객체, DB를 사용해 데이터를 조작하는 기능을 하는 객체 (MyBatis 사용시에 DAO or Mapper 사용)   Repository라고도 부름(JPA 사용시 Repository 사용)   Service 계층과 DB를 연결하는 고리 역할을 한다.     ✅분리된 계층 구조   RestController와 @Service를 나누는 이유     @Service를 만들어서 나누는 이유는 중복되는 코드가 생성을 피하기 위해 @Service로 분리한다.   비즈니스 로직은 다른 요청 URL에서 사용해야 하는 경우가 있다. 만약 비즈니스 로직 코드가 컨트롤러에 구현되어 있는 경우, 다른 컨트롤러의 핸들러 메소드에서 똑같은 로직코드를 구현해야되서, 중복코드가 발생하고 재사용성이 줄어든다.   중복되는 코드가 발생하면 따로 모듈화를 해서 나눠줘, 유지 보수를 쉽게할수 있음.   모든 기능들을 세분화해서 @Service에 작성하게 되면 나중에는 서비스의 기능들을 조합만 해서 새로운 기능을 만들 수 있음   서비스에서 다른 서비스를 의존성 참조하는 것도 가능하다.     즉, 비즈니스 로직의 서비스 구현체에서 구현하는 이유는 바로 확장성과 재사용성 그리고 중복 코드의 제거이다.      ✔ 동작 원리  Bean이란?    Spring이 관리하는 자바 객체   이 객체들은 Spring Container가 만들고, 필요할 때 자동으로 꺼내서 사용할 수 있다.   이걸 의존성 주입(DI) 이라고 한다.   ✅Bean으로 등록되는 과정  1. 클래스에 어노테이션 붙이기 아래 어노테이션을 클래스에 붙이면 자동으로 Bean등록    @Component → 일반 컴포넌트   @Service → 서비스 클래스   @Repository → DAO/DB 처리 클래스   @RestController → 웹 요청 처리 클래스   💡 위 어노테이션들은 @Component를 포함하고 있어서, 스프링이 @Component를 보고 등록을 한다.  2. 스프링이 Bean을 찾는 범위: @ComponentScan    @SpringBootApplication 안에는 @ComponentScan이 들어있다.   이 @ComponentScan이 지정된 패키지 안의 클래스들을 스캔하면서 @Component가 붙은 클래스들을 찾아서 Bean으로 등록을 한다.   💡 보통 @SpringBootApplication이 있는 메인 클래스 기준으로 하위 패키지만 스캔한다.  전체흐름 요약 @SpringBootApplication 실행   └ 내부의 @ComponentScan 작동     └ 지정된 패키지 내부에서 @Component가 붙은 클래스 찾기       └ @RestController, @Service, @Repository 등 포함         └ Bean으로 등록 (Spring이 객체를 만들어서 관리)   의존성 주입    스프링은 실행 시점에 생성자를 통해서 Bean으로 등록된 객체의 의존성을 자동으로 주입해준다.   🔗 참고 자료 (출처) 자세한 내용은 Gyun’s 개발일지 와 그릿 속의 해빗 참고하세요. "
  },
  
  {
    "title": "Dispatcher-Servlet",
    "url": "/posts/spring-dispatcherServlet/",
    "categories": "Spring, Study",
    "tags": "Spring, DispatcherServlet, MVC, FrontController, HandlerMapping, ViewResolver",
    "date": "2025-09-09 21:09:00 +0900",
    "content": "✅ Dispatcher Servlet  Dispatcher-Servlet이란? - HTTP프로토콜로 들어오는 모든 요청을 가장 먼저 받아, 적합한 컨트롤러에 위임해주는 프론트 컨트롤러(Front Controller)  상세설명)    클라이언트로부터 요청(Http프로토콜)이 오면 Tomcat과 같은 서블릿 컨테이너가 요청을 받음.   이 모든 요청을 프론트 컨트롤러인 디스패처 서블릿(Dispatcher-Servlet)이 가장 먼저 받음.   요청을 받은 디스패처 서블릿이 공통적인 작업을 먼저 처리후, 해당 요철을 처리하는 컨트롤러를 찾아 작업을 위임.   프론트 컨트롤러란? 서블릿 컨테이너의 제일 앞에서 서버로 들어오는 클라이언트의 모든 요청을 받아서 처리해주는 컨트롤러(MVC)구조에서 함께 사용되는 디자인 패턴.    ✅Dispatcher Servlet 동작 과정     클라이언트가 요청을 전송하면 DispatcherServlet이라는 클래스에 요청이 전달된다.   DispatcherServlet은 클라이언트의 요청을 처리할 Controller에 대한 검색을 HandlerMapping 인터페이스에게 요청한다.   HandlerMapping은 클라이언트 요청과 매핑되는 핸들러 객체를 다시 DispatcherServlet에게 리턴해준다.(핸들러 객체는 해당 핸들러의 Handler 메서드 정보를 포함하고 있다.Handler 메서드는 Controller 클래스 안에 구현된 요청 처리 메서드를 의미한다.)   요청을 처리할 Controller 클래스를 찾았으니 이제는 실제로 클라이언트 요청을 처리할 Handler 메서드를 찾아서 호출해야 한다. DispatcherServlet은 Handler 메서드를 직접 호출하지 않고, HandlerAdapter에게 Handler 메서드 호출을 위임한다.   HandlerAdapter는 DispatcherServlet으로부터 전달받은 Controller 정보를 기반으로 해당 Controller의 Handler 메서드를 호출한다.   Controller의 Handler 메서드는 비즈니스 로직 처리 후 리턴 받은 Model 데이터를 HandlerAdapter에게 전달한다.   HandlerAdapter는 전달받은 Model 데이터와 View 정보를 다시 DispatcherServlet에게 전달한다.(이때 핸들러 어댑터는 어떤 return 타입이든 모두 ModelAndView로 반환해준다.)   DispatcherServlet은 전달받은 View 정보를 다시 ViewResolver에게 전달해서 View 검색을 요청한다.   ViewResolver는 View 정보에 해당하는 View를 찾아서 View를 다시 리턴한다.   DispatcherServlet은 ViewResolver로부터 전달받은 View 객체를 통해 Model 데이터를 넘겨주면서 클라이언트에게 전달할 응답 데이터 생성을 요청한다.   View는 응답 데이터를 생성해서 다시 DispatcherServlet에게 전달한다.   DispatcherServlet은 View로부터 전달받은 응답 데이터를 최종적으로 클라이언트에게 전달한다   🔗 참고 자료 (출처) 자세한 내용은 망나니개발자 블로그 와 지구우중 블로그 참고하세요. "
  },
  
  {
    "title": "접근 제어자",
    "url": "/posts/java-access_modifier/",
    "categories": "Java, Study",
    "tags": "OOP, encapsulation, AccessModifier, java-basic",
    "date": "2025-09-03 20:32:00 +0900",
    "content": "✅ 접근 제어자 이해  접근제어자란? - 해당 클래스 외부에서 특정 필드나 메서드에 접근하는 것을 허용하거나 제한할수있는것.  에어컨 예제)    에어컨은 최고온도나 최저온도를 넘을수 없다.(넘어가면 에어컨이 고장난다.)   아래는 에어컨의 객체다.     package access;  public class AirConditioner {     int temperature;      // 생성자     public AirConditioner(int temperature) {         this.temperature = temperature;     }      // 온도 올리기     public void increaseTemp() {         if (temperature &gt;= 30) {             System.out.println(\"최고 온도입니다. 더 이상 온도를 올릴 수 없습니다.\");         } else {             temperature += 1;             System.out.println(\"온도를 1도 올립니다.\");         }     }      // 온도 내리기     public void decreaseTemp() {         if (temperature &lt;= 18) {             System.out.println(\"최저 온도입니다. 더 이상 온도를 내릴 수 없습니다.\");         } else {             temperature -= 1;             System.out.println(\"온도를 1도 내립니다.\");         }     }      // 현재 온도 확인     public void showTemperature() {         System.out.println(\"현재 설정 온도: \" + temperature + \"도\");     } }    AirConditionerMain  package access;  public class AirConditionerTest {     public static void main(String[] args) {         AirConditioner ac = new AirConditioner(22);          ac.showTemperature();         ac.increaseTemp();         ac.decreaseTemp();         ac.decreaseTemp();         ac.showTemperature();     } }    실행이 잘되는 코드이지만, 새로운 신입 개발자가 입사해,전후사정을 모르고 한계점을 넘게 설정을 했다고 가정하자.    package access;  public class AirConditionerTest {     public static void main(String[] args) {         AirConditioner ac = new AirConditioner(22);          ac.showTemperature();         ac.increaseTemp();         ac.decreaseTemp();         ac.decreaseTemp();         ac.showTemperature();                  //필드에 직점 접근       System.out.println(\"temperature필드에 직접 접근 수정\");       ac.temperature = 15;       ac.showTemperature();     } }  위의 코드가 실행이된다. 이렇게, AirConditioner객체를 사용하는 사용자는 AirConditioner의 temperature필드와 메서드에 모두 접근가능하다. 이런 상황에서 필드의 외부접근을 막을수 있는 방법이 필요하다.    해결방법    이 문제를 근본적으로 해결하는 방법은 temperature 필드를 AirConditioner 클래스 외부에서는 접근하지 못하게 막는 것!     package access;  public class AirConditioner {      private int temperature;   // ... }           private 접근 제어자는 모든 외부 호출을 막는다. 해당 클래스 내부에서만 호출 가능     🧱 접근 제어자 종류     자바는 총 4가지 졸유의 접근 제어자 제공      private: 모든 외부 호출 막음   default(package-private): 같은 패키지안에서 호출 허용   protected: 같은 패키지안에서만 호출 허용(패키지가 달라도 상속관계호출은 가능)   public: 모든 외부 호출 허용   순서대로 private가 차단이 높고, public은 차단이 없음 private -&gt; default -&gt; protected -&gt; public  package-private란? 접근제어자를 명시하지 않을때, 같은 패키지 안에서 호출을 허용하는 default접근 제어자가 적용, default 라는 용어는 해당 접근 제어자가 기본값으로 사용되기 때문에 붙여진 이름이지만,  실제로는 package-private 가 더 정확한 표현이다. 정리해서 해당 접근 제어자를 사용하는 멤버는 동일한 패키지 내의 다른 클래스에서만 접근이 가능하다.  접근 제어자 사용 위치 접근 제어자는 필드와 메서드, 생성자에 사용(클래스 레벨에도 일부 접근 제어자 사용가능)  접근 제어자의 핵심은 속성과 기능을 외부로부터 숨기는 것!    private는 사용중인 클래스 안으로 속성과 기능을 숨길 때, (외부클래스 제한)   default는 사용중인 패키지 안으로 속성과 기능을 숨길 때, (외부패키지 제한)   protected는 상속 관계로 속성과 기능을 숨길 때, (상속관계가 아니면 제한)   public은 기능을 숨기지 않음 (어디든 사용가능)   protected 예제  package access.parent;  public class Parent {     protected int value = 100; }    package access.child; import access.parent.Parent; public class Child extends Parent {     public void printValue() {         System.out.println(\"상속받은 value = \" + value);     } }    자바에서 클래스, 필드, 메서드, 생성자의 접근 가능 범위를 제어하는 키워드. 객체 지향의 중요한 개념인 캡슐화(Encapsulation)를 완성하는 핵심 장치.  필드와 메서드 레벨 접근 제어자  ✅ AirConditioner 예제  package access.a  public class AirConditioner { public int publicTemp = 24;     // 누구나 접근 가능 int defaultTemp = 22;           // 같은 패키지에서만 접근 가능 private int privateTemp = 20;   // 클래스 내부에서만 접근 가능      public void publicMethod() {         System.out.println(\"publicMethod 호출 \" + publicTemp);     }      void defaultMethod() {         System.out.println(\"defaultMethod 호출 \" + defaultTemp);     }      private void privateMethod() {         System.out.println(\"privateMethod 호출 \" + privateTemp);     }      // 내부에서만 private 멤버 접근 확인     public void innerAccess() {         System.out.println(\"내부 호출\");         publicTemp = 30;         defaultTemp = 28;         privateTemp = 26;          publicMethod();         defaultMethod();         privateMethod();     } }    같은 패키지에서 접근 —  package access.a;  public class AirConditionerInnerMain { public static void main(String[] args) { AirConditioner ac = new AirConditioner();          // public 접근 가능         ac.publicTemp = 25;         ac.publicMethod();          // default 접근 가능 (같은 패키지)         ac.defaultTemp = 23;         ac.defaultMethod();          // private 접근 불가         // ac.privateTemp = 21;         // ac.privateMethod();          ac.innerAccess(); // 내부에서 private도 접근 가능     } }   다른 패키지에서 접근 —  package access.b; import access.a.AirConditioner;  public class AirConditionerOuterMain { public static void main(String[] args) { AirConditioner ac = new AirConditioner();          // public 접근 가능         ac.publicTemp = 25;         ac.publicMethod();          // default 접근 불가 (다른 패키지)         // ac.defaultTemp = 23;         // ac.defaultMethod();          // private 접근 불가         // ac.privateTemp = 21;         // ac.privateMethod();          ac.innerAccess(); // public 메서드라 접근 가능     } }   3. 클래스 레벨 접근 제어자     클래스에는 public, default만 사용 가능   public 클래스는 파일명과 동일해야 함   하나의 자바 파일에 public 클래스는 1개만 가능, default 클래스는 여러 개 가능     package access.a;  public class PublicClass { public static void main(String[] args) { PublicClass pub = new PublicClass(); DefaultClass1 d1 = new DefaultClass1(); DefaultClass2 d2 = new DefaultClass2(); } }  class DefaultClass1 {} class DefaultClass2 {}     4. 캡슐화(Encapsulation) 개념    데이터(필드)와 기능(메서드)을 하나로 묶고, 불필요한 것은 숨기고 필요한 것만 노출하는 것   데이터는 반드시 숨기고(private), 외부에서는 제공된 메서드를 통해서만 접근해야 함     ✅ BankAccount 예제 (캡슐화 적용)  package access;  public class BankAccount { private int balance; // 데이터를 직접 접근 못 하게 보호      public BankAccount() {         balance = 0;     }      // 입금 (public)     public void deposit(int amount) {         if (isAmountValid(amount)) {             balance += amount;             System.out.println(amount + \"원 입금 완료\");         } else {             System.out.println(\"유효하지 않은 금액입니다.\");         }     }      // 출금 (public)     public void withdraw(int amount) {         if (isAmountValid(amount) &amp;&amp; balance - amount &gt;= 0) {             balance -= amount;             System.out.println(amount + \"원 출금 완료\");         } else {             System.out.println(\"유효하지 않은 금액이거나 잔액 부족\");         }     }      // 잔고 조회 (public)     public int getBalance() {         return balance;     }      // 금액 검증 (private → 내부에서만 사용)     private boolean isAmountValid(int amount) {         return amount &gt; 0;     } }   BankAccountMain package access;  public class BankAccountMain { public static void main(String[] args) { BankAccount account = new BankAccount();          account.deposit(10000);         account.withdraw(3000);         account.withdraw(8000);          System.out.println(\"최종 잔액 = \" + account.getBalance());     } }  📌 정리  접근 제어자    public: 모든 곳 접근 가능   default: 같은 패키지에서만   private: 클래스 내부에서만   protected: (지금 예제엔 없지만) 같은 패키지 + 상속 관계 접근 가능   클래스 레벨    public, default만 가능   public은 파일명과 같아야 함   캡슐화    데이터(필드)는 반드시 private   외부에는 꼭 필요한 public 메서드만 제공   내부 동작 검증용 메서드는 private으로 숨김  "
  },
  
  {
    "title": "생성자(Constructor)",
    "url": "/posts/java-Construct/",
    "categories": "Java, Study",
    "tags": "constructor, class, object, init",
    "date": "2025-08-28 18:30:00 +0900",
    "content": "✅ 생성자  객체를 생성하는 시점에 어떠한 작업을 하려면 생성자(Constructor)를 이용 해야 된다.  1. 필드만 있는 클래스 (CarInit) package construct;  public class CarInit {     String model;     String color;     int maxSpeed; }  2. 값을 일일이 직접 넣는 방식 (CarInitMain1) package construct;  public class CarInitMain1 {     public static void main(String[] args) {         CarInit car1 = new CarInit();         car1.model = \"Avante\";         car1.color = \"White\";         car1.maxSpeed = 180;          CarInit car2 = new CarInit();         car2.model = \"Sonata\";         car2.color = \"Black\";         car2.maxSpeed = 200;          CarInit[] cars = {car1, car2};         for (CarInit car : cars) {             System.out.println(\"모델:\" + car.model + \", 색상:\" + car.color + \", 최고속도:\" + car.maxSpeed + \"km/h\");         }     } }   ✅문제점    model, color, maxSpeed 값을 매번 수동으로 넣어야 함   같은 코드 반복 작성     3. 초기화 메서드를 사용한 개선 (CarInitMain2)   package construct;  public class CarInitMain2 {   public static void main(String[] args) {     CarInit car1 = new CarInit();     initCar(car1, \"Avante\", \"White\", 180);      CarInit car2 = new CarInit();     initCar(car2, \"Sonata\", \"Black\", 200);      CarInit[] cars = {car1, car2};     for (CarInit car : cars) {       System.out.println(\"모델:\" + car.model + \", 색상:\" + car.color + \", 최고속도:\" + car.maxSpeed + \"km/h\");     }   }    static void initCar(CarInit car, String model, String color, int maxSpeed) {     car.model = model;     car.color = color;     car.maxSpeed = maxSpeed;   } }     ✅ 개선점    중복 제거   코드 가독성 증가   ❌ 여전히 문제점    여전히 CarInit의 데이터는 외부에서 초기화   속성과 초기화 로직이 분리되어 있음 → 객체지향적으로 적절하지 않음 —   4. 생성자 도입 (Car)  package construct;  public class Car {   String model;   String color;   int maxSpeed;    // 생성자   public Car(String model, String color, int maxSpeed) {     this.model = model;     this.color = color;     this.maxSpeed = maxSpeed;   } }    5. 생성자 사용 (CarMain)  package construct;  public class CarMain {     public static void main(String[] args) {         Car car1 = new Car(\"Avante\", \"White\", 180);         Car car2 = new Car(\"Sonata\", \"Black\", 200);          Car[] cars = {car1, car2};         for (Car car : cars) {             System.out.println(\"모델:\" + car.model + \", 색상:\" + car.color + \", 최고속도:\" + car.maxSpeed + \"km/h\");         }     } }     장점    객체 생성과 동시에 초기화 → 실수로 초기화 안 하는 경우 방지   코드가 간결해짐     6. 기본생성자  package construct;  public class CarDefault {   String model;   String color;   int maxSpeed;    // 기본 생성자 (매개변수 없음)   public CarDefault() {     System.out.println(\"기본 생성자 호출\");   } }     사용코드(CarMain)  package construct;  public class CarMain {     public static void main(String[] args) {         Car car1 = new Car(\"Avante\", \"White\", 180);         Car car2 = new Car(\"Sonata\", \"Black\", 200);          Car[] cars = {car1, car2};         for (Car car : cars) {             System.out.println(\"모델:\" + car.model + \", 색상:\" + car.color + \", 최고속도:\" + car.maxSpeed + \"km/h\");         }     } }   클래스에 생성자를 하나도 정의하지 않으면 자바가 자동으로 기본 생성자를 만들어준다. 하지만 생성자를 직접 정의하면 기본 생성자는 자동으로 만들어지지 않는다. — 7. 생성자 오버로딩 package construct;  public class CarOverload {   String model;   String color;   int maxSpeed;    // 생성자1   public CarOverload(String model, String color) {     this(model, color, 150); // this()로 다른 생성자 호출   }    // 생성자2   public CarOverload(String model, String color, int maxSpeed) {     this.model = model;     this.color = color;     this.maxSpeed = maxSpeed;   } }  사용예시 package construct;  public class CarOverloadMain {   public static void main(String[] args) {     CarOverload car1 = new CarOverload(\"Avante\", \"White\", 180);     CarOverload car2 = new CarOverload(\"Sonata\", \"Black\"); // maxSpeed 기본값 150      System.out.println(car1.model + \" / \" + car1.color + \" / \" + car1.maxSpeed);     System.out.println(car2.model + \" / \" + car2.color + \" / \" + car2.maxSpeed);   } }    🔑 정리    생성자는 객체 생성 직후 반드시 호출된다.   생성자를 사용하면 필수 데이터 입력을 강제할 수 있다.   기본 생성자는 직접 생성자를 정의하지 않을 때만 자동 추가된다.        생성자 오버로딩과 this()를 활용하면 중복 제거 및 유연한 객체 생성이 가능하다.     "
  },
  
  {
    "title": "객체 지향 프로그래밍",
    "url": "/posts/java-Object-Oriented-Programming/",
    "categories": "Java, Study",
    "tags": "OOP, encapsulation, class, java-basic",
    "date": "2025-08-28 17:44:00 +0900",
    "content": "✅ 절차 지향 프로그래밍 vs 객체지향 프로그래밍     절차 지향 프로그래밍            절차 지향 프로그래밍은 이름 그대로 절차를 지향, 실행순서를 중요하게 생각하는 방식       절차 지향 프로그래밍은 프로그램의 흐름을 순차적으로 따르며 처리, “어떻게”를 중심으로 프로그래밍 한다.           객체 지향 프로그래밍            객체 지향 프로그래밍은 이름 그대로 객체를 지향, 객체를 중요하게 생각하는 방식       객체 지향 프로그래밍은 실제 세계의 사물이나 사건을 객체로 보고, 객체들간의 상호작용을 중심으로 프로그래밍 하는 방식. “무엇을” 중심으로 프로그래밍           둘의 중요한차이            절차지향은 데이터와 해당 데이터에 대한 ㅊ리 방식이 분리 되어 있음       객체지향은 데이터와 그 데이터에 대한 행동(메서드)이 하나의 ‘객체’안에 함께 포함 되어있다.             🧱 절차 지향 -&gt; 객체 지향 에어컨 제어 시스템  요구사항:    에어컨을 켜고 끌 수 있어야 한다.   에어컨의 온도를 증가, 감소할 수 있어야한다.   에어컨의 상태(on/off,현재 온도)를 확인 할 수 있어야 한다.   🔹 절차지향 1 - 변수로만 구현 package oop1;  public class AirConditionerMain1 {   public static void main(String[] args) {     int temperature = 24;     boolean isOn = false;      // 에어컨 켜기     isOn = true;     System.out.println(\"에어컨을 시작합니다\");      // 온도 증가     temperature++;     System.out.println(\"에어컨 온도: \" + temperature);      // 온도 감소     temperature--;     System.out.println(\"에어컨 온도: \" + temperature);      // 상태 확인     System.out.println(\"에어컨 상태 확인\");     if (isOn) {       System.out.println(\"에어컨 ON, 온도: \" + temperature);     } else {       System.out.println(\"에어컨 OFF\");     }      // 에어컨 끄기     isOn = false;     System.out.println(\"에어컨을 종료합니다\");   } }          순서대로 프로그램이 작동하도록 단순 작성     🔹 절차지향 2 - 데이터 묶음     클래스를 도입하고, AirConditionerData라는 클래스를 만들고, 에어컨에 사용되는 데이터들을 묶어서 멤버 변수로 사용      package oop1;  public class AirConditionerData {   int temperature = 24;   boolean isOn = false; }  에어컨에 사용되는 temperature, isOn 속성을 AirConditionerData의 멤버 변수에 포함  package oop1;  public class AirConditionerMain2 {   public static void main(String[] args) {     AirConditionerData ac = new AirConditionerData();      // 에어컨 켜기     ac.isOn = true;     System.out.println(\"에어컨을 시작합니다\");      // 온도 증가     ac.temperature++;     System.out.println(\"에어컨 온도: \" + ac.temperature);      // 온도 감소     ac.temperature--;     System.out.println(\"에어컨 온도: \" + ac.temperature);      // 상태 확인     System.out.println(\"에어컨 상태 확인\");     if (ac.isOn) {       System.out.println(\"에어컨 ON, 온도: \" + ac.temperature);     } else {       System.out.println(\"에어컨 OFF\");     }      // 에어컨 끄기     ac.isOn = false;     System.out.println(\"에어컨을 종료합니다\");   } }  에어컨과 관련된 변수들은 AirConditionerData ac 객체에 속해있으므로 쉽게 구분할 수 있다. — 🔹 절차지향 3 - 메서드 추출 중복되는 부분 : 온도 증가, 온도 감소 각 기능들의 재사용 가능성 : 에어컨 켜기/끄기 , 에어컨 상태확인 메서드를 사용 해 각 기능을 구분하여 실행 package oop1;  public class AirConditionerMain3 {   public static void main(String[] args) {     AirConditionerData ac = new AirConditionerData();      turnOn(ac);     increaseTemperature(ac);     decreaseTemperature(ac);     showStatus(ac);     turnOff(ac);   }    static void turnOn(AirConditionerData ac) {     ac.isOn = true;     System.out.println(\"에어컨을 시작합니다\");   }    static void turnOff(AirConditionerData ac) {     ac.isOn = false;     System.out.println(\"에어컨을 종료합니다\");   }    static void increaseTemperature(AirConditionerData ac) {     ac.temperature++;     System.out.println(\"에어컨 온도: \" + ac.temperature);   }    static void decreaseTemperature(AirConditionerData ac) {     ac.temperature--;     System.out.println(\"에어컨 온도: \" + ac.temperature);   }    static void showStatus(AirConditionerData ac) {     System.out.println(\"에어컨 상태 확인\");     if (ac.isOn) {       System.out.println(\"에어컨 ON, 온도: \" + ac.temperature);     } else {       System.out.println(\"에어컨 OFF\");     }   } }  각각의 기능을 메서드로 만들어 기능이 모듈화 되었고, 장점이 생김.    중복 제거: 로직 중복이 제거. 같은 로직이 필요하면 해당 메서드를 여러번 호출하면 된다.   변경 영향 범위: 기능을 수정할 때 해당 메서드 내부만 변경하면 된다.        메서드 이름 추가: 메서드 이름을 통해 코드를 더 쉽게 이해할 수 있다.     절차지향 프로그래밍의 한계      AirConditionerData는 단지 값만 가지고 있고,   AirConditionerMain3은 기능만 가지고 있음 → 데이터와 기능이 분리됨 ➡️ 유지보수할 때 양쪽 다 수정해야 함. ➡️ 객체 하나를 표현하는 데 관련된 코드가 여러 클래스에 흩어짐. —   🔗 객체 지향 프로그래밍 데이터와 기능을 하나로 묶어서 에어컨을 하나의 클래스로 만들고, 속성(데이터)을 가지고 기능(메서드)을 제공하는지에 초점 에어컨    속성: temperature, isOn   기능: turnOn, turnOff, increaseTemperature, decreaseTemperature, showStatus   package oop2;  public class AirConditioner {   private int temperature = 24;   private boolean isOn = false;    public void turnOn() {     isOn = true;     System.out.println(\"에어컨을 시작합니다\");   }    public void turnOff() {     isOn = false;     System.out.println(\"에어컨을 종료합니다\");   }    public void increaseTemperature() {     temperature++;     System.out.println(\"에어컨 온도: \" + temperature);   }    public void decreaseTemperature() {     temperature--;     System.out.println(\"에어컨 온도: \" + temperature);   }    public void showStatus() {     System.out.println(\"에어컨 상태 확인\");     if (isOn) {       System.out.println(\"에어컨 ON, 온도: \" + temperature);     } else {       System.out.println(\"에어컨 OFF\");     }   } }  package oop2;  public class AirConditionerMain {     public static void main(String[] args) {         AirConditioner ac = new AirConditioner();          ac.turnOn();         ac.increaseTemperature();         ac.decreaseTemperature();         ac.showStatus();         ac.turnOff();     } }     ➡️ 데이터와 기능을 하나로 묶는 것(캡슐화)은 객체지향의 핵심 원칙 중 하나이며, 현실 세계의 객체처럼 소프트웨어에서도 자연스럽게 객체를 표현할 수 있게 해준다. —  "
  },
  
  {
    "title": "Java 기본형 vs 참조형 요약",
    "url": "/posts/java-primitiveType_referenceType/",
    "categories": "Java, Study",
    "tags": "primitive, reference, datatype, java-basic",
    "date": "2025-08-20 15:30:00 +0900",
    "content": "✅ Java 데이터 타입 분류  자바의 데이터 타입은 크게 두 가지로 나뉜다:     기본형 (Primitive Type)   참조형 (Reference Type)     🧱 기본형 (Primitive Type)     데이터를 직접 값으로 저장한다.   총 8가지 타입이 존재한다.   메모리(stack)에 실제 값을 저장함.                  타입       크기       예시 값                       byte       1B       100                 short       2B       32000                 int       4B       123                 long       8B       123456789L                 float       4B       3.14f                 double       8B       3.14159                 char       2B       ‘A’                 boolean       1B       true / false           int a = 10; char ch = 'A'; boolean isAdult = true;          위처럼 변수에 사용할 값을 직접 넣을 수 있는 데이터 타입을 기본형이라 한다.      🔗 참조형 (Reference Type)     객체(Object)의 주소값을 저장한다.   클래스, 배열, 인터페이스 등 대부분의 사용자 정의 데이터.   heap에 객체 데이터를 만들고, 그 주소를 stack에 저장.   String name = \"Alice\";           // String 객체의 주소 저장 int[] scores = {90, 80, 100};    // 배열도 참조형 Student student = new Student(); // 클래스도 참조형          위처럼 데이터에 접근하기 위한 참조(주소)를 저장하는 데이터 타입을 참조형이라고 한다. 참조형은 객체 또는 배열에 사용한다.      🧠 주요 차이                 비교 항목       기본형 (Primitive)       참조형 (Reference)                       저장 내용       실제 값 (value)       객체 주소 (reference)                 메모리 위치       Stack       객체는 Heap, 참조는 Stack                 null 저장       ❌ 불가능       ✅ 가능 (null로 초기화 가능)                 예시       int, double, boolean       String, 배열, 사용자 클래스             기본형 vs 참조형 - 기본    기본형은 숫자 10, 20과 같이 실제 사용하는 값을 변수에 담을 수 있다.(해당값 바로 사용할수 있음)   참조형은 실제 사용하는 값을 변수에 담는 것이 아님, 이름 그대로 실제 객체의 위치(참조,주소)를 저장한다. 참조형에는 객체와 배열이 있음            객체는 .(dot)을 통해서 메모리 상에 생성된 객체를 찾아가 사용       배열은 []를 통해서 메모리 상에 생성된 객체를 찾아가 사용           기본형 vs 참조형 - 계산    기본형은 들어있는 값을 그대로 계산에 사용            ex) 더하고 빼고, 사용하고 등(숫자 같은 것들은 바로 계산)           참조형은 들어있는 참조값을 그대로 사용할 수 없다. 주소지만 가지고 할 수 있는게 없음, 주소지에 가야 사용가능            ex) 더하고 빼고 사용하고 못함, 참조값만 가지고는 계산불가.            📌 예제 비교  int x = 10; int y = x;       // 값 복사  x = 20; System.out.println(y);  // 10 (영향 X)   int[] arr1 = {1, 2, 3}; int[] arr2 = arr1;   // 주소 복사  arr1[0] = 99; System.out.println(arr2[0]); // 99 (같은 객체를 가리킴)      👉 기본형은 값을 복사, 참조형은 주소를 공유한다는 점이 핵심!     🧠 기본형 vs 참조형: 메서드 호출  자바는 항상 변수의 값을 복사해서 대입한다. 이 원칙은 메서드 호출 시에도 동일하게 적용된다.    ✅ 기본형: 값만 복사  public class MethodChange1 {   public static void main(String[] args) {     int a = 10;     System.out.println(\"메서드 호출 전: a = \" + a);     changePrimitive(a);     System.out.println(\"메서드 호출 후: a = \" + a);   }    static void changePrimitive(int x) {     x = 20;   } }   실행 결과:  메서드 호출 전: a = 10 메서드 호출 후: a = 10   설명    a의 값이 x에 복사됨 → 두 변수는 별개   x = 20은 a에 영향을 주지 않음     ✅ 참조형: 참조값이 복사됨  public class MethodChange2 {   public static void main(String[] args) {     Data dataA = new Data();     dataA.value = 10;     System.out.println(\"메서드 호출 전: dataA.value = \" + dataA.value);     changeReference(dataA);     System.out.println(\"메서드 호출 후: dataA.value = \" + dataA.value);   }    static void changeReference(Data dataX) {     dataX.value = 20;   } }   실행 결과:  메서드 호출 전: dataA.value = 10 메서드 호출 후: dataA.value = 20   설명    dataA의 참조값이 dataX에 복사됨 → 두 변수는 같은 객체를 가리킴   dataX.value = 20은 dataA.value에도 영향     ✅ 정리                 구분       전달 방식       메서드 내부 변경 시 호출자에 영향                       기본형       값 복사       ❌ 없음                 참조형       참조값 복사       ✅ 있음              자바의 매개변수 전달은 항상 값에 의한 전달(Call by Value).   기본형은 실제 값을, 참조형은 주소(참조값)를 복사.     ✅ 핵심 요약     변수에 대입 = 값 복사   메서드 호출 = 매개변수도 값 복사   참조형의 경우 복사된 값이 참조값이라 객체 내용은 변경 가능     🧪 null 주의  Student s = null; System.out.println(s.name); // ❌ NullPointerException     ✅ 요약     기본형: 숫자, 문자, 논리 등 값 자체를 다룸   참조형: 객체나 배열 등 실제 데이터 위치를 가리킴   참조형은 null, 공유, heap 등을 항상 염두에 둘 것    "
  },
  
  {
    "title": "Java 클래스 요약",
    "url": "/posts/java-class-summary/",
    "categories": "Java, Study",
    "tags": "class, OOP, java-basic",
    "date": "2025-08-12 15:00:00 +0900",
    "content": "📌 클래스와 데이터 문제상황    학생 정보를 다룰 때 이름, 나이, 성적 등 여러 데이터를 저장해야 함   변수로 처리하면: 학생 1명당 3개의 변수 필요 → 학생 늘어나면 코드 폭발   배열로 처리하면: 데이터가 나뉘어 저장됨 → 인덱스 관리 어려움, 실수 위험      💡 클래스를 사용하면 관련 데이터를 묶어서 구조화할 수 있어 유지보수에 유리합니다.   해결책: 클래스  public class Student {   String name;   int age;   int grade; }  하나의 객체에 관련 데이터를 묶어서 표현 Student student1 = new Student(); // Student 클래스 기반 객체 생성 student1.name = \"학생\";            // 객체의 필드에 값 할당 student1.age = 15; student1.grade = 90;     객체 생성: new 클래스명()   객체 참조: 객체변수.멤버변수   ✅ 자바 클래스 핵심 요약    ✅ 클래스 = 사용자 정의 타입     int, String처럼 직접 만든 데이터 타입이 될 수 있음   클래스를 사용하면 현실 세계의 개념(학생, 자동차 등)을 프로그래밍 세계에 맞게 표현할 수 있음   클래스는 설계도, 객체는 그 설계도로 만들어진 실제 실체 (= 인스턴스)     ✅ 클래스 도입 효과                 방법       단점 또는 문제점                       변수       학생 늘어나면 변수 폭발                 배열       관련 데이터가 배열로 나뉘어 관리 어려움                 클래스       ✅ 관련 데이터를 묶어 구조화, 유지보수 용이             ✅ 용어 정리                 클래스(Class)       객체를 만들기 위한 설계도, 사용자 정의 데이터 타입                       객체(Object) / 인스턴스(Instance)       클래스를 바탕으로 만들어진 메모리 상의 실제 실체 (동일한 의미로 사용됨)                       필드(Field)       클래스 내부에 선언된 변수 (= 멤버 변수). 객체의 상태(데이터)를 저장함           배열과 클래스    Student[] students = new Student[2]; 형태로 배열 선언   객체 배열을 통해 여러 학생 정보를 관리할 수 있음   Student[] students = {student1, student2}; for (Student s : students) {     System.out.println(\"이름:\" + s.name + \" 나이:\" + s.age + \" 성적:\" + s.grade); }  "
  }
  
]

